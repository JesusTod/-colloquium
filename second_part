import numpy as np
import collections
import math
import random
# 35. Дан лінійний масив цілих чисел. Перевірте, чи є він упорядкованим по
# спаданню.
a = np.array((), dtype=int)
while True:
    inp = input()           # добавляємо елементи в масив з клавіатури, поки не натиснуть два рази enter
    if not inp:
        break
    a = np.append(a, int(inp))
b = np.sort(a)              # створюємо змінну b яка є відсортованим по наростанню а
k = 1
while k != (len(a)+1):      # проходимося по єлементах масиву
    if k == len(a):         # якщо k стало як кількість елементів масиву тоді елементи упорядкованні по спаданню
        print('Елементи упорядковані по спаданню')
    elif a[k-1] == b[-k]:   # зрівнюємо елементи а з початку, та b з кінця та пропускаємо
        pass
    else:                   # якщо хоча б раз не буде виконано ні if ні elif тоді перериваємо роботу циклу
        print('Елементи упорядковані не по спаданню')
        break
    k += 1

####################################################################################################################
# 36. Знайти суму додатніх елементів лінійного масиву цілих чисел.
# Розмірність масиву - 10. Заповнення масиву здійснити з клавіатури.
a = np.zeros(10, dtype=int)             # масив, 10 елементів, всі нулі
summa = 0
for i in range(len(a)):                 # заповнюємо масив з клавіатури
    a[i] = int(input())
    if a[i] > 0:                        # якщо елемент додатній, то добавляємо його в summa
        summa += a[i]
print(summa)

####################################################################################################################
# 37. Розсортуйте заданий лінійний масив по зростанню.
a = np.array((), dtype=int)
while True:
    inp = input()           # добавляємо елементи в масив з клавіатури, поки не натиснуть два рази enter
    if not inp:
        break
    a = np.append(a, int(inp))
a = np.sort(a)              # за допомогою метода numpy.sort() ми відсортували масив по зростанню
print(a)

####################################################################################################################
# 38. Дані про направлення вітру (північний, південний, східний, західний) і
# силі вітру за декаду листопада зберігаються в масиві. Визначити, скільки днів дув
# південний вітер з силою, що перевищує 8 м / с.
wind = np.array(('Північний', 'Південний', 'Східний', 'Західний'))
power = np.array(((1, 2, 3, 4, 5, 6, 7, 8, 9, 10),      # Північний
                  (11, 10, 9, 8, 7, 6, 5, 4, 3, 2),     # Південний
                  (7, 6, 7, 4, 8, 2, 3, 9, 10, 5),      # Східний
                  (5, 3, 6, 4, 7, 4, 6, 9, 6, 7)))      # Західний
days = 0
for i in range(len(power[1])):      # проходимося по всіх елементах Південного вітру
    if power[1][i] > 8:             # якщо елемент більше 8, то добавляємо в days 1
        days += 1
print(days)

####################################################################################################################
# 39. Дані про температуру повітря і кількості опадів за декаду квітня
# зберігаються в масивах. Визначити кількість опадів, що випали у вигляді дощу і у
# вигляді снігу за цю декаду.
a = np.array((12, 8, 5, -1, -1, -2, 0, 3, 5, 6))    # температура
b = np.array((1, 2, 3, 4, 5, 6, 7, 8, 9, 10))       # кількість опадів
rain = 0
snow = 0
for i in range(10):                     # пробігаємось по значенням масиву
    if a[i] < 0:                        # якщо температура меньше нулю, то добавляємо b[і-тий] елемент в snow
        snow += b[i]
    else:
        rain += b[i]                    # інакше добавляємо b[i-тий] елемент в rain
print('У вигляді дощу:', rain)
print('У вигляді снігу:', snow)

####################################################################################################################
# 40. Обчислити суму парних елементів одновимірного масиву до першого
# зустрінутого нульового елемента.
a = np.array((), dtype=int)
while True:
    inp = input()           # добавляємо елементи в масив з клавіатури, поки не натиснуть два рази enter
    if not inp:
        break
    a = np.append(a, int(inp))
summa = 0
for i in range(len(a)):
    if a[i] != 0:           # якщо елемент не дорівнює нулю, то добавляємо його в summa
        summa += a[i]
    else:                   # в іншому випадку, перериваемо роботу цикла
        break
print(summa)

####################################################################################################################
# 41. Змінній t привласнити значення істина, якщо максимальний елемент
# одновимірного масиву єдиний і не перевищує наперед заданого числа а.
m = np.array((), dtype=int)
t = False
while True:
    inp = input('Введіть елемент матриці:')           # добавляємо елементи в масив з клавіатури, поки не натиснуть два рази enter
    if not inp:
        break
    m = np.append(m, int(inp))
a = int(input('Введіть число: '))
count = collections.Counter(m)              # порахували кількість всіх елементів в масиві
if max(m) < a and count[max(m)] < 2:        # якщо максимальний ел. меньше а та кількість максимальних ел. меньше 2
    t = True                                # тоді ми присвоюємо t значення True
print(t)

####################################################################################################################
# 42. Підрахувати кількість елементів одновимірного масиву, для яких
# виконується нерівність i*i<ai<i!
a = np.array((), dtype=int)
while True:
    inp = input()           # добавляємо елементи в масив з клавіатури, поки не натиснуть два рази enter
    if not inp:
        break
    a = np.append(a, int(inp))
summa = 0
for i in range(len(a)):
    if i*i < a[i] < i:
        summa += 1
print(summa)

####################################################################################################################
# 43. Задано два натуральних числа a і b. Змінній w привласнити значення
# істина, якщо в одновимірному цілочисельному масиві є хоча б один елемент, кратний а
# і не кратний b.
m = np.array((), dtype=int)
w = False
while True:
    inp = input('Введіть елемент масиву')  # добавляємо елементи в масив з клавіатури, поки не натиснуть два рази enter
    if not inp:
        break
    m = np.append(m, int(inp))
a = int(input('Введіть а'))
b = int(input('Введіть b'))
for i in range(len(m)):                    # проходимось по елементах масиву
    if m[i] % a == 0 and m[i] % b != 0:    # якщо елемент кратний а і не кратний b одночасно, то w = True
        w = True
        break                              # цикл перестає працювати
print(w)

####################################################################################################################
# 44. Підрахуйте кількість елементів одновимірного масиву, які збігаються зі
# своїм номером і при цьому кратні 3.
a = np.array((), dtype=int)
while True:
    inp = input()           # добавляємо елементи в масив з клавіатури, поки не натиснуть два рази enter
    if not inp:
        break
    a = np.append(a, int(inp))
count = 0
for i in range(len(a)):                 # проходимось по елементах масиву
    if a[i] == i and a[i] % 3 == 0:     # якщо елемент == своєму індексу і кратний 3, то count += 1
        count += 1
print(count)

####################################################################################################################
# 45. Перетин даху має форму півкола з радіусом R м. Сформувати таблицю,
# яка містить довжини опор, які встановлюються через кожні R / 5 м.
a = int(input('Введіть радіус півкола: '))                     # просимо ввести  радіус півкола
b = []  # створюємо пустий список
for i in range(a // 5):
    b.append(math.sqrt(a ** 2 - ((a / 5) * (4 - i)) ** 2))     # рахуваємо довжину опори(за т.Піфагора)
for i in range(len(b) - 2, -1, -1):
    b.append(b[i])                                             # добавляємо наш елемент в список
print(b)                                                       # виводимо довжини опор

####################################################################################################################
# 46. Задана таблиця назв товарів, що випускаються заводом. Визначте, чи
# повторюється в цій таблиці назва першого товару, і, якщо повторюється, видаліть
# назву першого товару з таблиці.
a = np.array(())
while True:
    inp = input()           # добавляємо елементи в масив з клавіатури, поки не натиснуть два рази enter
    if not inp:
        break
    a = np.append(a, inp)
count = collections.Counter(a)      # отримали інформацію про цількість всіх елементів
if count[a[0]] > 1:                 # якщо кількість першого елементу більше 1
    a = np.delete(a, 0)             # то ми видаляємо його з масиву
print(a)

####################################################################################################################
# 47. У лінійному масиві знайти максимальний елемент. Вставте порядковий
# номер елемента за ним, пересунувши всі залишилися на одну позицію вправо.
a = np.array([1, 2, 3, 4, 5, 6, 7, 65, 2, 7, 2, 53, 15, 1])
max_index = 0
for i in range(len(a)):             # знаходимо максимальний елемент в масиві
    if a[i] == max(a):
        max_index = i
right = a[max_index+1:len(a)]       # отримали зріз всіх елементів по праву сторону від максимального
a = a[0:max_index+1]                # видалили елементи по праву сторону
a = np.append(a, max_index)         # добавили в кінець масиву індекс максимального числаі
a = np.append(a, right)             # добавили в кінець праву сторону яку видалили раніше
print(a)

####################################################################################################################
# 48. Наведено список прізвищ брокерів товарної біржі з N чоловік. Поміняйте
# місцями прізвища брокерів: першого і останнього, другого і передостаннього, третього
# з початку і третього від кінця і т.д.
a = np.array(())
while True:
    inp = input()
    if not inp:
        break
    a = np.append(a, inp)
if len(a) % 2 == 0:                         # якщо парна кількість елементів
    for i in range(len(a)):
        if i == len(a)/2:                   # якщо цикл до середини, тобто вже поміняли всі елменти, перериваємо цикл
            break
        a[i], a[-i-1] = a[-i-1], a[i]       # міняємо останній елемент з першим, і так далі
else:                                       # якщо не парна кількість
    for i in range(len(a)):
        if i == len(a) / 2 - 0.5:           # якщо цикл дойшов до елемента Перед середнім, то перериваємо цикл
            break
        a[i], a[-i - 1] = a[-i - 1], a[i]
print(a)

####################################################################################################################
# 49. Задано дві таблиці. Одна містить найменування послуг, а інша - розцінки
# за ці послуги. Видаліть з обох таблиць все, що передує послузі, ціна якої G гривень.
a = np.array(())
b = np.array(())
while True:                             # вводимо в масиви значення
    inp = input('Введіть послугу')
    inp2 = input('Введіть ціну')
    if not inp:
        break
    a = np.append(a, inp)
    b = np.append(b, inp2)
G = input('Введіть G')
for i in range(len(b)):                 # шукаємо індекс сумми яка == заданій G
    if b[i] == G:
        a = a[i:len(a)]            # робимо зріз всіх елементів що знаходяться після G, тобто видаляємо все що перед G
        b = b[i:len(b)]
        break
print(a)
print(b)

####################################################################################################################
# 50. У лотереї розігрувалося 100 квитків. Таблиця містить 10 номерів
# виграшних квитків. Перевірте, чи є квиток з номером N виграшним.
tickets = np.arange(100)                     # створили квитки від 1 до 100
win = np.array(())
k = 0
N = int(input('Введіть номер квитка'))
while k != 100:                               # генератор випадкових 10 виграшних квитків, без повторень
    x = random.choice(tickets)
    if x not in win:                        # якщо x не є в win, то ми його добавляємо. інакше вибираємо заново
        win = np.append(win, x)
        k += 1
if N in win:                                # якщо задане N є в win, то квиток N є виграшним
    print('Ваш квиток є виграшним!')
else:
    print('Ваш квиток не є виграшним')
print('Виграшні номери:',win)

####################################################################################################################
# 51. Дан одновимірний масив а. Сформувати новий масив, який складається
# тільки з тих елементів масиву а, які перевищують свій номер на 10. Якщо таких
# елементів немає, то видати повідомлення.
a = np.array(())
while True:                     # вводимо значення з клавіатури поки не натиснимо два рази Enter
    inp = input()
    if not inp:
        break
    a = np.append(a, inp)
new = np.array(())
for i in range(len(a)):
    if int(a[i]) - i == 10:     # якщо елемент більше свого індексу рівно на 10, то добавляємо його в new
        new = np.append(new, a[i])
if len(new) > 0:                # якщо в новому мавиві є хоча б один елемен, виводимо його на екран
    print('Елементи які перевищували свій номер на 10:', new)
else:
    print('Таких елементів немає')

####################################################################################################################
# 52. Знайти найбільший елемент з елементів одновимірного масиву, що мають
# парний номер. Визначити, чи є він єдиним.
a = np.array(())
while True:                     # вводимо значення з клавіатури поки не натиснимо два рази Enter
    inp = input()
    if not inp:
        break
    a = np.append(a, inp)
b = np.array(())
max_ = 0
for i in range(len(a)):
    if i % 2 == 0:              # додаємо в масив b всі елементи індекс яких кратний двом
        b = np.append(b, a[i])
        if int(a[i]) > int(max_) or a[i] == a[0]:   # шукаємо максимальний елемент в масиві b
            max_ = a[i]
        else:
            pass
count = collections.deque.count(collections.deque(b),max_)  # за допомогою метода collections, ми знайшли кількість максимального елементу
print('Найбільший елемент:', max_, 'Його кількість:', count)

####################################################################################################################
# 53. В масиві X (1: n) кожен елемент рівний 0, 1 або 5. Переставити елементи
# масиву так, щоб спочатку розташовувалися всі нулі, потім все одиниці, а потім всі
# п'ятірки. Додаткового масиву не заводити.
X = np.array(())
n = int(input('Введіть n:'))
element = np.array((0, 1, 5))
for i in range(n):                              # цикл працює стільки раз, скільки задав користувач
    X = np.append(X, random.choice(element))    # добавляємо рандомний вибір між 0, 1, 5.
X = np.sort(X)                                  # сортуємо масив по зростанню
print(X)

####################################################################################################################
# 54. Введіть масив з 20 елементів і визначте, чи є в ньому елементи з
# однаковими значеннями.
a = np.array(())
for i in range(20):                         # вводимо в масив 20 елементів з клавіатури
    a = np.append(a, input())
count = collections.Counter(a).most_common(1)[0][1]     # знаходимо кількість найбільш зустрічаємих елементів
print(count)
if int(count) > 1:                          # якщо якийсь елемент зустрівся більше ніж 1 раз, тоді однакові значення є
    print('Однакові значення є')
else:
    print('Однакових значень немає')

####################################################################################################################
# 55. У будинку, що складається з 30 квартир, переселити мешканців так, щоб
# мешканці першої квартири переїхали в тридцяту, з тридцятого - в першу, з другої - в 29
# і т.д., знайдіть кількість квартир, в яких проживає більше 5 осіб.
count = np.array((1, 2, 3, 4, 5, 6))
people = np.array(())
for i in range(30):
    people = np.append(people, random.choice(count))
print('Мешканців в квартирах до переселення',people)
for i in range(len(people)):             # міняємо мешканців місцями
    if i == len(people) / 2:             # якщо цикл до середини, тобто вже поміняли всі елменти, перериваємо цикл
        break
    people[i], people[-i - 1] = people[-i - 1], people[i]
print('Мешканців в квартирах після переселення', people)
count = collections.deque.count(collections.deque(people), 5)   # знайшли кількість п'ятірок в масиві
print(count)

####################################################################################################################
# 56. Якщо в одновимірному масиві є три поспіль однакових елемента, то
# змінній r привласнити значення істина.
a = np.array(())
r = False
while True:                     # вводимо значення з клавіатури поки не натиснимо два рази Enter
    inp = input()
    if not inp:
        break
    a = np.append(a, inp)
for i in range(len(a)):                 # проходимося по елементах масиву
    if i == len(a)-2:                   # якщо елемент передостанній, то буде помилка out of range
        break                           # тому ми перериваємо роботу циклу
    else:
        if a[i] == a[i+1] == a[i+2]:    # якщо три елемента підряд однакові, тоді r стає True
            r = True
print(r)

####################################################################################################################
# 57. Відомість на зарплату представлена як дві таблиці. Одна містить
# прізвища працівників цеху, а друга - їх зарплату за поточний місяць. Знайдіть прізвище
# працівника, зарплата якого найменш відхиляється від середньої зарплати всіх
# працівників за поточний місяць. Знайдіть прізвища двох працівників з найбільшою
# заробітною платою. Видаліть з відомості на зарплату відомості про працівника,
# зарплата якого мінімальна.
p = np.array(('Келіп', 'Мельник', 'Цаль', 'Іванов', 'Білик', 'Проць'))
z = np.array((125, 649, 1120, 255, 700, 900))
seredne = 0
for i in range(len(z)):             # проходимося по елементах, та додаємо їх до змінної seredne
    seredne += z[i]
    if z[i] == min(z):
        mn = i                      # отримали індекс мінімального елементу в з масиву z
seredne = seredne / len(z)
minus = 0
k = 0
close = 0
while k != len(z):
    present = z[k] - seredne        # завели змінну яка == попередньому елементу - середнє арифметичне
    if k == 0:
        minus = z[0] - seredne      # теперішній елемент - середнє арифметичне
    elif k >= 1:
        if math.fabs(present) < math.fabs(minus):   # якщо модуль теперішьного більше за попереднє значення
            minus = z[k] - seredne                  # тоді в наступному циклі попередній елемент стає z[k] - сер. ариф.
            close = k                               # на виході з циклу маємо індекс потрібного нам елементу/призвіща
    k += 1
print('Найменш відхиляється зарплата:', p[close])
p_2 = np.copy(p)
z_2 = np.copy(z)
m_1 = max(z)
a = collections.deque.index(collections.deque(z),min(z),0,len(z))   # індекс мінімальної зарплати
z = np.delete(z, a)                             # видалили мінімальну зарплату
p = np.delete(p, a)                             # видалили фамілію
print(z)


l = np.copy(z)                                   # робимо копію масиву з зарплатами
for m in range(len(l) - 1):                      # сотруємо за selection
    n = m
    for o in range(m + 1, len(l)):
        if l[o] > l[n]:                          # за зменшенням
            n = o
    l[m], l[n] = l[n], l[m]
s = l[:2]                                        # зріз, з двох крайніх елементів
for q in range(len(z)):                          # знаходимо найбільші елементи
    if z[q] == s[0] or z[q] == s[1]:             # порівнюємо іх з зрізом s, який є двома макс. значеннями
        print('Вища зарплата:', p[q])

####################################################################################################################
# 58. Дан одновимірний масив цілих чисел. Знайдіть, скільки разів в ньому
# повторюється найчастіше число.
a = np.array(())
while True:                     # вводимо значення з клавіатури поки не натиснимо два рази Enter
    inp = input()
    if not inp:
        break
    a = np.append(a, inp)
count = collections.Counter.most_common(collections.Counter(a))[0]  # за допомогою метода most_common ми отримали інформацію про повторення всіх чисел
print('Найчастіше число', count[0], 'повторяється:', count[1])      # всі данні в most_common зберігаються в порядку спадання, і тоді найперше буде набільше разів повторюватися

####################################################################################################################
# 59. Дан одновимірний масив з 10 цілих чисел. Підрахуйте кількість різних
# чисел в ньому.
a = np.array(())
while True:                     # вводимо значення з клавіатури поки не натиснимо два рази Enter
    inp = input()
    if not inp:
        break
    a = np.append(a, inp)
count = collections.Counter.most_common(collections.Counter(a))
print(len(count))       # len метода most_common дає нам кількість всіх чисел (без повторень) в порядку спадання.

####################################################################################################################
# 60. Дан одновимірний масив з 10 цілих чисел. Підрахуйте найбільше число
# однакових чисел, що йдуть підряд в ньому.
a = np.array(())
count_np = np.array(())
while True:                     # вводимо значення з клавіатури поки не натиснимо два рази Enter
    inp = input()
    if not inp:
        break
    a = np.append(a, inp)
k = 0
count = 0
while k != len(a)-1:            # проходимось по елементах масиву а
    if a[k] == a[k+1]:          # якщо елемент == наступному, тоді добавляємо в count 1
        count += 1
    else:
        count = 0               # якщо елемент не == наступному, тоді обнуляємо значення count
    print(count)
    k += 1
    count_np = np.append(count_np, count)   # кожен раз добавляжємо в масив count_np значення count для знаходження найбільшого
print(max(count_np)+1)                      # виводимо максимальне значення масиву + 1
